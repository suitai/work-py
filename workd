#!/usr/bin/env python

import os
import sys
import shlex
from subprocess import Popen 
from signal import SIGTERM
try:
    import psutil
    from talk import Listener,DataDictionary
    import jobinfo
except ImportError, detail:
    sys.exit('ImportError: %s' % detail)

PID_FILE = '/var/run/workd.pid'
LOG_FILE = './workd.log'

class Worker(Listener):
    def __init__(self):
        Listener.__init__(self)
        self.job_data = DataDictionary()

    def react(self, message):
        pass

    def enqueue_act(self, ident, queue_name, message):
        message_list = message.split()
        uid = 0
        gid = 0
        cwd = ''
        shell = '/bin/sh'
        job = ''
        for num,word in enumerate(message_list):
            if word == 'UID':
                uid = message_list[num + 1]
            elif word == 'GID':
                gid = message_list[num + 1]
            elif word == 'CWD':
                cwd = message_list[num + 1]
            elif word == 'SHELL':
                shell = message_list[num + 1]
            elif word == 'JOB':
                job = message_list[num + 1]
        job_info = {'queue':queue_name, 'uid':uid, 'gid':gid, 'cwd':cwd, 'shell':shell, 'job':job,
                    'status':'Queued', 'popen':None}
        self.job_data.put_info(ident, job_info)

    def dequeue_act(self, ident, queue_name, message):
        """ start work """
        log_prefix = ('[%s-%s]' % (queue_name,str(ident).zfill(3)))
        # set jobinfo
        job_info = self.job_data.get_info(ident)
        jobinfo.jobid = ident
        jobinfo.queue = job_info['queue']
        jobinfo.uid = int(job_info['uid'])
        jobinfo.gid = int(job_info['gid'])
        jobinfo.cwd = job_info['cwd']
        jobinfo.shell = job_info['shell']
        self.logger.info('%s work start' % log_prefix)
        # get job_message 
        message_list = message.split()
        for num, word in enumerate(message_list):
            if word == 'JOB':
                job_message = ' '.join(message_list[num + 1:])
        # prework
        self.job_data.set_value(ident, 'status', 'PreWork')
        try:
            import prework
            self.logger.info('%s prework done' % log_prefix)
        except ImportError:
            self.logger.warn('%s no prework' % log_prefix)
        # work
        outdir = ('%s' % queue_name)
        if not os.path.exists(outdir):
            os.mkdir(outdir)
        # write job script
        job_script = ('%s/job-%s.sh' % (outdir,str(ident).zfill(3)))
        file = open(job_script, 'w')
        file.write(job_message)
        file.close()
        # open job out file
        job_out = ('%s/job-%s.out' % (outdir,str(ident).zfill(3)))
        file = open(job_out, 'w')
        # popen
        try:
            popen = Popen((jobinfo.shell, job_script), stdout=file, stderr=file)
            self.logger.debug('%s popen "%s"' % (log_prefix,job_message))
            self.job_data.set_value(ident, 'status', 'Running')
            self.job_data.set_value(ident, 'popen', popen)
            popen.communicate()
        except OSError, detail:
            self.logger.error('OSError: %s', detail)
        finally:
            file.close()
        jobinfo.returncode = popen.returncode
        # postwork
        self.job_data.set_value(ident, 'status', 'PostWork')
        try:
            import postwork
            self.logger.info('%s postwork done' % log_prefix)
        except ImportError:
            self.logger.warn('%s no postwork' % log_prefix)
        self.job_data.set_value(ident, 'status', 'Finished')

def usage():
    sys.stdout.write('usage: %s [start|status|stop]\n' % sys.argv[0])

def _get_pid_from_file(pidfile):
    try:
        file = open(pidfile, 'r')
        return int(file.read())
    except IOError, detail:
        sys.exit('Worker is not running')

if __name__ == "__main__":
    if len(sys.argv) > 1:
        if sys.argv[1] == 'start':
            # start a daemon
            if not os.getuid() == 0:
                sys.exit('Error: You must be root')
            worker = Worker()
            worker.daemonize(pidfile=PID_FILE, logfile=LOG_FILE)
            sys.stdout.write('Info: Worker daemon start\n')
        elif sys.argv[1] == 'status':
            # check the daemon status
            pid = _get_pid_from_file(PID_FILE)
            if pid in psutil.get_pid_list():
                sys.stdout.write('Info: Worker is running\n')
            else:
                sys.exit('Error: Worker is not running')
        elif sys.argv[1] == 'stop':
            # kill the daemon
            if not os.getuid() == 0:
                sys.exit('Error: You must be root')
            pid = _get_pid_from_file(PID_FILE)
            try:
                os.kill(pid, SIGTERM)
                sys.stdout.write('Info: Worker killed\n')
            except OSError, detail:
                sys.exit('Error: Cannot kill Worker: %s' % detail)
        elif sys.argv[1] == 'run':
            # start a process
            if not os.getuid() == 0:
                sys.exit('Error: You must be root')
            worker = Worker()
            worker.start() 
        else:
            usage()
    else:
        usage()
